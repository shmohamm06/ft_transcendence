import{P as R,i as P,j as _,f as x,k as z,B as U,l as W,m as N,H as G,W as Z,A as X,I as g,n as L,o as B,p as Y,C as b,b as O,E as C,q as m,r as H,s as V,F as I,t as j,u as q,v as $}from"./index-D3RIXwi_.js";const J=20000630;function v(n,l){if(n.getUint32(0,!0)!=J)throw new Error("Incorrect OpenEXR format");const e=n.getUint8(4),a=n.getUint8(5),t={singleTile:!!(a&2),longName:!!(a&4),deepFormat:!!(a&8),multiPart:!!(a&16)};l.value=8;const r={};let s=!0;for(;s;){const i=R(n.buffer,l);if(!i)s=!1;else{const c=R(n.buffer,l),o=P(n,l),u=_(n,l,c,o);u===void 0?x.Warn(`Unknown header attribute type ${c}'.`):r[i]=u}}if(a&-5)throw new Error("Unsupported file format");return{version:e,spec:t,...r}}function K(n){let l=n.byteLength;const e=[];let a=0;const t=new DataView(n);for(;l>0;){const r=t.getInt8(a++);if(r<0){const s=-r;l-=s+1;for(let i=0;i<s;i++)e.push(t.getUint8(a++))}else{const s=r;l-=2;const i=t.getUint8(a++);for(let c=0;c<s+1;c++)e.push(i)}}return e}function F(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function Q(n){const l=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),e=new Uint8Array(K(l)),a=new Uint8Array(e.length);return L(e),B(e,a),new DataView(a.buffer)}function k(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(l),a=new Uint8Array(e.length);return L(e),B(e,a),new DataView(a.buffer)}function d(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(l),a=n.lines*n.channels*n.width,t=n.type==1?new Uint16Array(a):new Uint32Array(a);let r=0,s=0;const i=new Array(4);for(let c=0;c<n.lines;c++)for(let o=0;o<n.channels;o++){let u=0;switch(n.type){case 1:i[0]=r,i[1]=i[0]+n.width,r=i[1]+n.width;for(let h=0;h<n.width;++h){const w=e[i[0]++]<<8|e[i[1]++];u+=w,t[s]=u,s++}break;case 2:i[0]=r,i[1]=i[0]+n.width,i[2]=i[1]+n.width,r=i[2]+n.width;for(let h=0;h<n.width;++h){const w=e[i[0]++]<<24|e[i[1]++]<<16|e[i[2]++]<<8;u+=w,t[s]=u,s++}break}}return new DataView(t.buffer)}function nn(n){const l=n.viewer,e={value:n.offset.value},a=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),t=new Uint8Array(U);let r=0;const s=new Array(n.channels);for(let f=0;f<n.channels;f++)s[f]={},s[f].start=r,s[f].end=s[f].start,s[f].nx=n.width,s[f].ny=n.lines,s[f].size=n.type,r+=s[f].nx*s[f].ny*s[f].size;const i=z(l,e),c=z(l,e);if(c>=U)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(i<=c)for(let f=0;f<c-i+1;f++)t[f+i]=W(l,e);const o=new Uint16Array(Y),u=N(t,o),h=P(l,e);G(n.array,l,e,h,a,r);for(let f=0;f<n.channels;++f){const p=s[f];for(let y=0;y<s[f].size;++y)Z(a,p.start+y,p.nx,p.size,p.ny,p.nx*p.size,u)}X(o,a,r);let w=0;const E=new Uint8Array(a.buffer.byteLength);for(let f=0;f<n.lines;f++)for(let p=0;p<n.channels;p++){const y=s[p],A=y.nx*y.size,S=new Uint8Array(a.buffer,y.end*g,A*g);E.set(S,w),w+=A*g,y.end+=A}return new DataView(E.buffer)}async function M(n,l,e,a){const t={size:0,viewer:l,array:new Uint8Array(l.buffer),offset:e,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case b.NO_COMPRESSION:t.lines=1,t.uncompress=F;break;case b.RLE_COMPRESSION:t.lines=1,t.uncompress=Q;break;case b.ZIPS_COMPRESSION:t.lines=1,t.uncompress=k,await O.LoadScriptAsync(C.FFLATEUrl);break;case b.ZIP_COMPRESSION:t.lines=16,t.uncompress=k,await O.LoadScriptAsync(C.FFLATEUrl);break;case b.PIZ_COMPRESSION:t.lines=32,t.uncompress=nn;break;case b.PXR24_COMPRESSION:t.lines=16,t.uncompress=d,await O.LoadScriptAsync(C.FFLATEUrl);break;default:throw new Error(b[n.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const r={};for(const o of n.channels)switch(o.name){case"R":case"G":case"B":case"A":r[o.name]=!0,t.type=o.pixelType;break;case"Y":r[o.name]=!0,t.type=o.pixelType;break}let s=!1;if(r.R&&r.G&&r.B&&r.A)t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(r.R&&r.G&&r.B)s=!0,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(r.R&&r.G)t.outputChannels=2,t.decodeChannels={R:0,G:1};else if(r.R)t.outputChannels=1,t.decodeChannels={R:0};else if(r.Y)t.outputChannels=1,t.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(t.type===1)switch(a){case m.Float:t.getter=H,t.inputSize=g;break;case m.HalfFloat:t.getter=z,t.inputSize=g;break}else if(t.type===2)switch(a){case m.Float:t.getter=j,t.inputSize=I;break;case m.HalfFloat:t.getter=V,t.inputSize=I}else throw new Error("Unsupported pixelType "+t.type+" for "+n.compression);t.blockCount=t.height/t.scanlineBlockSize;for(let o=0;o<t.blockCount;o++)q(l,e);const i=t.width*t.height*t.outputChannels;switch(a){case m.Float:t.byteArray=new Float32Array(i),t.textureType=1,s&&t.byteArray.fill(1,0,i);break;case m.HalfFloat:t.byteArray=new Uint16Array(i),t.textureType=2,s&&t.byteArray.fill(15360,0,i);break;default:throw new Error("Unsupported type: "+a)}let c=0;for(const o of n.channels)t.decodeChannels[o.name]!==void 0&&(t.channelLineOffsets[o.name]=c*t.width),c+=o.pixelType*2;return t.bytesPerLine=t.width*c,t.outLineWidth=t.width*t.outputChannels,n.lineOrder==="INCREASING_Y"?t.scanOrder=o=>o:t.scanOrder=o=>t.height-1-o,t.outputChannels==4?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}function D(n,l,e,a){const t={value:0};for(let r=0;r<n.height/n.scanlineBlockSize;r++){const s=$(e,a)-l.dataWindow.yMin;n.size=P(e,a),n.lines=s+n.scanlineBlockSize>n.height?n.height-s:n.scanlineBlockSize;const c=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):F(n);a.value+=n.size;for(let o=0;o<n.scanlineBlockSize;o++){const u=r*n.scanlineBlockSize,h=o+n.scanOrder(u);if(h>=n.height)continue;const w=o*n.bytesPerLine,E=(n.height-1-h)*n.outLineWidth;for(let f=0;f<n.channels;f++){const p=l.channels[f].name,y=n.channelLineOffsets[p],A=n.decodeChannels[p];if(A!==void 0){t.value=w+y;for(let S=0;S<n.width;S++){const T=E+S*n.outputChannels+A;n.byteArray&&(n.byteArray[T]=n.getter(c,t))}}}}}}class en{constructor(){this.supportCascades=!1}loadCubeData(l,e,a,t,r){throw".exr not supported in Cube."}loadData(l,e,a){const t=new DataView(l.buffer),r={value:0},s=v(t,r);M(s,t,r,C.DefaultOutputType).then(i=>{D(i,s,t,r);const c=s.dataWindow.xMax-s.dataWindow.xMin+1,o=s.dataWindow.yMax-s.dataWindow.yMin+1;a(c,o,e.generateMipMaps,!1,()=>{const u=e.getEngine();e.format=s.format,e.type=i.textureType,e.invertY=!1,e._gammaSpace=!s.linearSpace,i.byteArray&&u._uploadDataToTextureDirectly(e,i.byteArray,0,0,void 0,!0)})}).catch(i=>{x.Error("Failed to load EXR texture: ",i)})}}async function an(n){const l=new DataView(n),e={value:0},a=v(l,e);try{const t=await M(a,l,e,m.Float);return D(t,a,l,e),t.byteArray?{width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,data:new Float32Array(t.byteArray)}:(x.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(t){x.Error("Failed to load EXR data: ",t)}return{width:0,height:0,data:null}}export{an as ReadExrDataAsync,en as _ExrTextureLoader};
